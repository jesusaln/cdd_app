<?php

namespace App\Services;

use App\Models\BackupLog;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage as StorageFacade;
use Aws\S3\S3Client;
use Google\Cloud\Storage\StorageClient;
use ZipArchive;

/**
 * Servicio para gestionar respaldos de la base de datos.
 */
class DatabaseBackupService
{
    protected string $backupDisk = 'local';

    protected string $backupPath = 'backups/database/';

    public function __construct()
    {
        // Permitir configurar disco y ruta desde config/backup.php o .env
        $this->backupDisk = config('backup.disk', $this->backupDisk);
        $configuredPath = config('backup.path', $this->backupPath);
        // Normalizar y asegurar trailing slash
        $configuredPath = str_replace('\\', '/', trim($configuredPath));
        $this->backupPath = rtrim($configuredPath, '/') . '/';
    }

    /**
     * Obtener lista de tablas sensibles desde configuración
     */
    protected function getSensitiveTables(): array
    {
        return config('backup.security.sensitive_tables', [
            'users',
            'clientes',
            'personal_access_tokens',
            'password_resets',
            'failed_jobs',
            'user_notifications',
            'bitacora_actividades'
        ]);
    }

    /**
     * Configuración de seguridad
     */
    protected array $securityConfig = [
        'encrypt_sensitive_data' => true,
        'use_checksums' => true,
        'backup_integrity_check' => true,
        'max_backup_age_days' => 90,
        'require_password_confirmation' => true
    ];

    /**
     * Configuración de almacenamiento remoto
     */
    protected function getRemoteStorageConfig(): array
    {
        return config('backup.remote_storage', [
            'enabled' => false,
            'primary_provider' => 's3', // s3, gcs, azure, dropbox
            'providers' => [
                's3' => [
                    'enabled' => env('BACKUP_S3_ENABLED', false),
                    'key' => env('AWS_ACCESS_KEY_ID'),
                    'secret' => env('AWS_SECRET_ACCESS_KEY'),
                    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
                    'bucket' => env('BACKUP_S3_BUCKET'),
                    'path' => env('BACKUP_S3_PATH', 'backups/database/'),
                ],
                'gcs' => [
                    'enabled' => env('BACKUP_GCS_ENABLED', false),
                    'project_id' => env('GOOGLE_CLOUD_PROJECT_ID'),
                    'key_file' => env('GOOGLE_APPLICATION_CREDENTIALS'),
                    'bucket' => env('BACKUP_GCS_BUCKET'),
                    'path' => env('BACKUP_GCS_PATH', 'backups/database/'),
                ],
                'azure' => [
                    'enabled' => env('BACKUP_AZURE_ENABLED', false),
                    'account_name' => env('AZURE_STORAGE_NAME'),
                    'account_key' => env('AZURE_STORAGE_KEY'),
                    'container' => env('BACKUP_AZURE_CONTAINER'),
                    'path' => env('BACKUP_AZURE_PATH', 'backups/database/'),
                ]
            ],
            'sync_local_and_remote' => env('BACKUP_SYNC_BOTH', true),
            'cleanup_remote' => env('BACKUP_CLEANUP_REMOTE', true),
            'remote_retention_days' => env('BACKUP_REMOTE_RETENTION', 90)
        ]);
    }

    /**
     * Configuración de notificaciones desde archivo de configuración
     */
    protected function getNotificationConfig(): array
    {
        return config('backup.notifications', [
            'email_enabled' => true,
            'slack_enabled' => false,
            'notify_on_backup_success' => true,
            'notify_on_backup_failure' => true,
            'notify_on_restore' => true,
            'notify_on_security_issues' => true,
            'notify_admin_on_critical_errors' => true,
            'daily_digest_enabled' => false,
            'weekly_report_enabled' => true
        ]);
    }

    /**
     * Configuración de seguridad desde archivo de configuración
     */
    protected function getSecurityConfig(): array
    {
        return config('backup.security', [
            'encrypt_sensitive_data' => true,
            'use_checksums' => true,
            'backup_integrity_check' => true,
            'max_backup_age_days' => 90,
            'require_password_confirmation' => true
        ]);
    }

    /**
     * Crear un nuevo respaldo de la base de datos.
     *
     * @param  array  $options  Opciones: 'name', 'compress'
     * @return array ['success' => bool, 'message' => string, 'path' => string, 'size' => int]
     */
    public function createBackup(array $options = []): array
    {
        $filename = $this->generateFilename($options['name'] ?? null);
        $fullPath = $this->backupPath.$filename;

        $logData = [
            'filename' => basename($fullPath),
            'path' => $fullPath,
            'type' => 'sql',
            'method' => null,
            'status' => 'failed',
            'message' => null,
            'metadata' => [
                'compress' => $options['compress'] ?? false,
                'driver' => config('database.default'),
            ],
        ];

        try {
            if (! $this->hasEnoughDiskSpace(500 * 1024 * 1024)) {
                throw new \Exception('Espacio en disco insuficiente');
            }

            $driver = config('database.default');
            $specificTables = $options['tables_to_backup'] ?? null;

            if ($driver === 'mysql' && $this->isMysqldumpAvailable() && !$specificTables) {
                $result = $this->createBackupWithMysqldump($fullPath, $specificTables);
                $logData['method'] = 'mysqldump';
            } elseif ($driver === 'pgsql' && $this->isPgDumpAvailable() && !$specificTables) {
                $result = $this->createBackupWithPgDump($fullPath, $specificTables);
                $logData['method'] = 'pg_dump';
            } else {
                $result = $this->createBackupWithLaravel($fullPath, $specificTables);
                $logData['method'] = 'laravel';
            }

            if (! $result['success']) {
                throw new \Exception($result['message']);
            }

            $logData['status'] = 'success';
            $logData['size'] = $result['size'];
            $logData['message'] = $result['message'];

            if (($options['compress'] ?? false) && $result['success']) {
                $compressResult = $this->compressBackup($result['path']);
                if ($compressResult['success']) {
                    $result = $compressResult;
                    $logData['path'] = $result['path'];
                    $logData['type'] = 'zip';
                    $logData['size'] = $result['size'];
                    $logData['message'] .= ' (comprimido)';
                } else {
                    throw new \Exception('Compresión fallida: '.$compressResult['message']);
                }
            }

            BackupLog::create($logData);

            // Enviar notificación de éxito
            $this->sendNotification('backup_success', [
                'filename' => basename($result['path']),
                'size' => $result['size'],
                'size_formatted' => $this->formatBytes($result['size']),
                'method' => $logData['method']
            ]);

            return $result;
        } catch (\Exception $e) {
            $logData['message'] = $e->getMessage();
            BackupLog::create($logData);

            Log::error('DatabaseBackupService - createBackup failed', [
                'exception' => $e,
                'options' => $options,
            ]);

            // Enviar notificación de error
            $this->sendNotification('backup_failure', [
                'error' => $e->getMessage(),
                'options' => $options
            ]);

            return [
                'success' => false,
                'message' => 'Error al crear respaldo: '.$e->getMessage(),
            ];
        }
    }

    /**
     * Crear respaldo incremental basado en cambios desde último backup
     *
     * @param  array  $options  Opciones para backup incremental
     * @return array ['success' => bool, 'message' => string, 'path' => string, 'size' => int, 'changes_detected' => int]
     */
    public function createIncrementalBackup(array $options = []): array
    {
        try {
            $lastBackup = $this->getLastBackupInfo();

            if (!$lastBackup) {
                // Si no hay backup anterior, crear backup completo
                Log::info('No se encontró backup anterior, creando backup completo');
                return $this->createSecureBackup(array_merge($options, [
                    'incremental' => false,
                    'name' => ($options['name'] ?? 'backup') . '_full_' . date('Y-m-d_H-i-s')
                ]));
            }

            // Detectar cambios desde último backup
            $changes = $this->detectDatabaseChanges($lastBackup['created_at']);

            if (empty($changes['modified_tables']) && empty($changes['new_tables'])) {
                return [
                    'success' => true,
                    'message' => 'No se detectaron cambios desde el último backup',
                    'incremental' => true,
                    'changes_detected' => 0,
                    'skipped' => true
                ];
            }

            // Crear backup solo con tablas modificadas
            $result = $this->createSecureBackup(array_merge($options, [
                'incremental' => true,
                'tables_to_backup' => array_merge($changes['modified_tables'], $changes['new_tables']),
                'base_backup' => $lastBackup['filename'],
                'name' => ($options['name'] ?? 'backup') . '_incremental_' . date('Y-m-d_H-i-s')
            ]));

            if ($result['success']) {
                $result['changes_detected'] = count($changes['modified_tables']) + count($changes['new_tables']);
                $result['modified_tables'] = $changes['modified_tables'];
                $result['new_tables'] = $changes['new_tables'];
                $result['total_rows_affected'] = $changes['total_rows_affected'];

                Log::info('Backup incremental creado exitosamente', [
                    'changes_detected' => $result['changes_detected'],
                    'modified_tables' => $changes['modified_tables'],
                    'new_tables' => $changes['new_tables']
                ]);
            }

            return $result;

        } catch (\Exception $e) {
            Log::error('Error creando backup incremental: ' . $e->getMessage(), [
                'options' => $options
            ]);

            return [
                'success' => false,
                'message' => 'Error creando backup incremental: ' . $e->getMessage()
            ];
        }
    }

    /**
     * Detectar cambios en la base de datos desde timestamp específico
     */
    protected function detectDatabaseChanges(string $sinceTimestamp): array
    {
        $changes = [
            'modified_tables' => [],
            'new_tables' => [],
            'total_rows_affected' => 0
        ];

        try {
            $tables = $this->getAllTables();
            $sinceDate = Carbon::parse($sinceTimestamp);

            foreach ($tables as $table) {
                $tableName = $table->table_name ?? $table->TABLE_NAME;

                // Verificar si la tabla existe y cuándo fue modificada por última vez
                $lastModified = $this->getTableLastModified($tableName);

                if (!$lastModified) {
                    // Tabla nueva
                    $changes['new_tables'][] = $tableName;
                    $rowCount = $this->getTableRowCount($tableName);
                    $changes['total_rows_affected'] += $rowCount;
                } elseif ($lastModified->gt($sinceDate)) {
                    // Tabla modificada
                    $changes['modified_tables'][] = $tableName;
                    $newRows = $this->getNewRowsCount($tableName, $sinceDate);
                    $changes['total_rows_affected'] += $newRows;
                }
            }

        } catch (\Exception $e) {
            Log::error('Error detectando cambios en BD: ' . $e->getMessage());
        }

        return $changes;
    }

    /**
     * Obtener información del último backup disponible
     */
    protected function getLastBackupInfo(): ?array
    {
        $backups = $this->listBackups();

        if (empty($backups)) {
            return null;
        }

        // Buscar el backup más reciente que no sea incremental
        $fullBackups = array_filter($backups, function($backup) {
            return !str_contains($backup['name'], 'incremental');
        });

        if (empty($fullBackups)) {
            return null;
        }

        // Ordenar por fecha de creación (más reciente primero)
        uasort($fullBackups, function($a, $b) {
            return strtotime($b['created_at']) - strtotime($a['created_at']);
        });

        $latestBackup = reset($fullBackups);

        return [
            'filename' => $latestBackup['name'],
            'created_at' => $latestBackup['created_at'],
            'size' => $latestBackup['size']
        ];
    }

    /**
     * Obtener fecha de última modificación de una tabla
     */
    protected function getTableLastModified(string $tableName): ?Carbon
    {
        try {
            $driver = config('database.default');

            switch ($driver) {
                case 'mysql':
                    $result = DB::select("
                        SELECT UPDATE_TIME
                        FROM information_schema.tables
                        WHERE TABLE_SCHEMA = DATABASE()
                        AND TABLE_NAME = ?
                    ", [$tableName]);

                    if (!empty($result) && $result[0]->UPDATE_TIME) {
                        return Carbon::parse($result[0]->UPDATE_TIME);
                    }
                    break;

                case 'pgsql':
                    $result = DB::select("
                        SELECT GREATEST(
                            (SELECT MAX(created) FROM pg_stat_user_tables WHERE relname = ?),
                            (SELECT MAX(modified) FROM pg_stat_user_tables WHERE relname = ?)
                        ) as last_modified
                    ", [$tableName, $tableName]);

                    if (!empty($result) && $result[0]->last_modified) {
                        return Carbon::parse($result[0]->last_modified);
                    }
                    break;

                case 'sqlite':
                    // SQLite no tiene metadatos de modificación incorporados
                    // Usar timestamp del archivo de la base de datos
                    $dbPath = config('database.connections.sqlite.database');
                    if (file_exists($dbPath)) {
                        return Carbon::createFromTimestamp(filemtime($dbPath));
                    }
                    break;
            }

            return null;
        } catch (\Exception $e) {
            Log::warning("Error obteniendo última modificación de tabla {$tableName}: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Obtener conteo de filas nuevas desde fecha específica
     */
    protected function getNewRowsCount(string $tableName, Carbon $sinceDate): int
    {
        try {
            // Buscar columnas de timestamp comunes
            $timestampColumns = ['created_at', 'updated_at', 'fecha_creacion', 'fecha_actualizacion'];

            foreach ($timestampColumns as $column) {
                $count = DB::table($tableName)
                    ->where($column, '>', $sinceDate)
                    ->count();

                if ($count > 0) {
                    return $count;
                }
            }

            // Si no hay columnas de timestamp, contar todas las filas (considerar tabla modificada)
            return DB::table($tableName)->count();

        } catch (\Exception $e) {
            Log::warning("Error contando filas nuevas en tabla {$tableName}: " . $e->getMessage());
            return 0;
        }
    }

    /**
     * Obtener conteo total de filas de una tabla
     */
    protected function getTableRowCount(string $tableName): int
    {
        try {
            return DB::table($tableName)->count();
        } catch (\Exception $e) {
            Log::warning("Error contando filas en tabla {$tableName}: " . $e->getMessage());
            return 0;
        }
    }

    /**
     * Crear respaldo con características de seguridad avanzadas
     *
     * @param  array  $options  Opciones adicionales de seguridad
     * @return array ['success' => bool, 'message' => string, 'path' => string, 'size' => int, 'checksum' => string]
     */
    public function createSecureBackup(array $options = []): array
    {
        $securityConfig = $this->getSecurityConfig();

        $options = array_merge([
            'encrypt_sensitive' => $securityConfig['encrypt_sensitive_data'],
            'generate_checksum' => $securityConfig['use_checksums'],
            'include_integrity_check' => $securityConfig['backup_integrity_check'],
            'require_confirmation' => $securityConfig['require_password_confirmation']
        ], $options);

        // Verificar permisos si es requerido
        if ($options['require_confirmation'] && !isset($options['confirmed'])) {
            return [
                'success' => false,
                'message' => 'Se requiere confirmación explícita para crear respaldos seguros',
                'requires_confirmation' => true
            ];
        }

        $result = $this->createBackup($options);

        if (!$result['success']) {
            return $result;
        }

        $backupPath = $result['path'];
        $fullPath = Storage::disk($this->backupDisk)->path($backupPath);
        $checksum = null;

        try {
            // Generar checksum si está habilitado
            if ($options['generate_checksum']) {
                $checksum = $this->generateChecksum($fullPath);
                $result['checksum'] = $checksum;
            }

            // Encriptar datos sensibles si está habilitado
            if ($options['encrypt_sensitive']) {
                $encryptedPath = $this->encryptSensitiveData($fullPath, $backupPath);
                if ($encryptedPath) {
                    $result['path'] = $encryptedPath;
                    $result['encrypted'] = true;
                    $result['size'] = filesize(Storage::disk($this->backupDisk)->path($encryptedPath));
                }
            }

            // Verificación de integridad si está habilitada
            if ($options['include_integrity_check']) {
                $integrityResult = $this->verifyBackupIntegrity($result['path']);
                $result['integrity_verified'] = $integrityResult['success'];
                if (!$integrityResult['success']) {
                    $result['integrity_warnings'] = $integrityResult['warnings'] ?? [];
                }
            }

            Log::info('Respaldo seguro creado exitosamente', [
                'path' => $result['path'],
                'size' => $result['size'],
                'encrypted' => $result['encrypted'] ?? false,
                'checksum' => $checksum
            ]);

        } catch (\Exception $e) {
            Log::error('Error en respaldo seguro: ' . $e->getMessage(), [
                'backup_path' => $backupPath,
                'options' => $options
            ]);

            return [
                'success' => false,
                'message' => 'Error creando respaldo seguro: ' . $e->getMessage()
            ];
        }

        return $result;
    }

    /**
     * Encriptar datos sensibles en el respaldo
     */
    protected function encryptSensitiveData(string $filePath, string $relativePath): ?string
    {
        if (!file_exists($filePath)) {
            return null;
        }

        $content = file_get_contents($filePath);
        if (!$content) {
            return null;
        }

        $encryptedContent = Crypt::encrypt($content);
        $encryptedPath = str_replace(['.sql', '.zip'], ['_encrypted.sql', '_encrypted.zip'], $relativePath);

        if (Storage::disk($this->backupDisk)->put($encryptedPath, $encryptedContent)) {
            // Eliminar archivo original después de encriptar
            unlink($filePath);
            return $encryptedPath;
        }

        return null;
    }

    /**
     * Generar múltiples checksums para verificación avanzada de integridad
     */
    protected function generateChecksum(string $filePath): array
    {
        if (!file_exists($filePath)) {
            throw new \Exception('Archivo no encontrado para generar checksum');
        }

        $fileSize = filesize($filePath);
        $handle = fopen($filePath, 'rb');

        if (!$handle) {
            throw new \Exception('No se pudo abrir el archivo para generar checksum');
        }

        $chunkSize = 8192; // 8KB chunks
        $totalChunks = ceil($fileSize / $chunkSize);

        // Inicializar hashes
        $md5 = hash_init('md5');
        $sha1 = hash_init('sha1');
        $sha256 = hash_init('sha256');
        $crc32 = 0;

        $chunkIndex = 0;
        while (!feof($handle)) {
            $chunk = fread($handle, $chunkSize);

            // Actualizar hashes
            hash_update($md5, $chunk);
            hash_update($sha1, $chunk);
            hash_update($sha256, $chunk);

            // Calcular CRC32 del chunk
            $crc32 ^= crc32($chunk);

            $chunkIndex++;

            // Verificar progreso cada 100 chunks para archivos grandes
            if ($chunkIndex % 100 === 0) {
                Log::debug("Procesando chunk {$chunkIndex}/{$totalChunks} para checksum");
            }
        }

        fclose($handle);

        return [
            'md5' => hash_final($md5),
            'sha1' => hash_final($sha1),
            'sha256' => hash_final($sha256),
            'crc32' => sprintf('%08x', $crc32),
            'file_size' => $fileSize,
            'chunk_count' => $chunkIndex,
            'generated_at' => now()->toISOString()
        ];
    }

    /**
     * Verificar integridad avanzada de un archivo usando múltiples algoritmos
     */
    public function verifyAdvancedIntegrity(string $filename, array $expectedChecksums = null): array
    {
        $path = $this->backupPath.$filename;

        if (!$this->backupExists($filename)) {
            return [
                'success' => false,
                'message' => 'El archivo de respaldo no existe.',
                'error_code' => 'FILE_NOT_FOUND'
            ];
        }

        $fullPath = $this->getBackupPath($filename);

        try {
            // Verificaciones básicas primero
            $basicChecks = $this->performBasicFileChecks($fullPath);
            if (!$basicChecks['success']) {
                return $basicChecks;
            }

            // Generar checksums actuales
            $currentChecksums = $this->generateChecksum($fullPath);

            // Si no se proporcionan checksums esperados, solo devolver información
            if (!$expectedChecksums) {
                return [
                    'success' => true,
                    'message' => 'Verificación completada - no hay checksums de referencia',
                    'checksums' => $currentChecksums,
                    'verification_level' => 'current_only'
                ];
            }

            // Comparar checksums
            $comparison = $this->compareChecksums($currentChecksums, $expectedChecksums);

            if (!$comparison['match']) {
                return [
                    'success' => false,
                    'message' => 'Los checksums no coinciden - posible corrupción de archivo',
                    'expected_checksums' => $expectedChecksums,
                    'current_checksums' => $currentChecksums,
                    'mismatches' => $comparison['mismatches'],
                    'error_code' => 'CHECKSUM_MISMATCH'
                ];
            }

            return [
                'success' => true,
                'message' => 'Verificación de integridad exitosa',
                'checksums' => $currentChecksums,
                'verification_level' => 'full',
                'algorithms_verified' => ['md5', 'sha1', 'sha256', 'crc32']
            ];

        } catch (\Exception $e) {
            Log::error('Error en verificación avanzada de integridad: ' . $e->getMessage(), [
                'filename' => $filename,
                'expected_checksums' => $expectedChecksums
            ]);

            return [
                'success' => false,
                'message' => 'Error durante la verificación: ' . $e->getMessage(),
                'error_code' => 'VERIFICATION_ERROR'
            ];
        }
    }

    /**
     * Realizar verificaciones básicas del archivo
     */
    protected function performBasicFileChecks(string $filePath): array
    {
        // Verificar existencia
        if (!file_exists($filePath)) {
            return [
                'success' => false,
                'message' => 'Archivo no encontrado',
                'error_code' => 'FILE_NOT_FOUND'
            ];
        }

        // Verificar tamaño
        $size = filesize($filePath);
        if ($size === 0) {
            return [
                'success' => false,
                'message' => 'Archivo vacío',
                'error_code' => 'EMPTY_FILE'
            ];
        }

        // Verificar permisos de lectura
        if (!is_readable($filePath)) {
            return [
                'success' => false,
                'message' => 'No se puede leer el archivo',
                'error_code' => 'PERMISSION_DENIED'
            ];
        }

        // Verificar que no esté corrupto (intentar abrir)
        $handle = fopen($filePath, 'r');
        if (!$handle) {
            return [
                'success' => false,
                'message' => 'Archivo corrupto o ilegible',
                'error_code' => 'CORRUPTED_FILE'
            ];
        }

        // Leer primeros bytes para verificar estructura básica
        $header = fread($handle, 1024);
        fclose($handle);

        if (empty(trim($header))) {
            return [
                'success' => false,
                'message' => 'Archivo sin contenido válido',
                'error_code' => 'INVALID_CONTENT'
            ];
        }

        return [
            'success' => true,
            'message' => 'Verificaciones básicas exitosas',
            'file_size' => $size,
            'can_read' => true
        ];
    }

    /**
     * Comparar checksums actuales con esperados
     */
    protected function compareChecksums(array $current, array $expected): array
    {
        $mismatches = [];
        $algorithms = ['md5', 'sha1', 'sha256', 'crc32'];

        foreach ($algorithms as $algorithm) {
            if (isset($expected[$algorithm]) && isset($current[$algorithm])) {
                if (strtolower($expected[$algorithm]) !== strtolower($current[$algorithm])) {
                    $mismatches[] = $algorithm;
                }
            }
        }

        return [
            'match' => empty($mismatches),
            'mismatches' => $mismatches,
            'algorithms_checked' => $algorithms
        ];
    }

    /**
     * Verificar integridad del respaldo
     */
    protected function verifyBackupIntegrity(string $relativePath): array
    {
        $fullPath = Storage::disk($this->backupDisk)->path($relativePath);

        if (!file_exists($fullPath)) {
            return [
                'success' => false,
                'message' => 'Archivo no encontrado para verificación'
            ];
        }

        $warnings = [];
        $size = filesize($fullPath);

        // Verificaciones básicas
        if ($size === 0) {
            $warnings[] = 'Archivo vacío detectado';
        }

        if ($size > 500 * 1024 * 1024) { // 500MB
            $warnings[] = 'Archivo muy grande, verificación puede tomar tiempo';
        }

        // Verificar que el archivo no esté corrupto
        $handle = fopen($fullPath, 'r');
        if (!$handle) {
            return [
                'success' => false,
                'message' => 'No se puede leer el archivo'
            ];
        }

        // Leer primeros bytes para verificar estructura básica
        $header = fread($handle, 1024);
        fclose($handle);

        if (strpos($header, 'SQL') === false && strpos($header, 'CREATE') === false) {
            $warnings[] = 'El archivo puede no tener formato SQL válido';
        }

        return [
            'success' => true,
            'warnings' => $warnings,
            'file_size' => $size,
            'can_read' => true
        ];
    }

    /**
     * Crear respaldo usando mysqldump (solo MySQL).
     *
     * @param  string  $path  Ruta relativa
     * @param  array|null  $specificTables  Tablas específicas a respaldar
     */
    protected function createBackupWithMysqldump(string $path, ?array $specificTables = null): array
    {
        $config = config('database.connections.'.config('database.default'));
        $storagePath = Storage::disk($this->backupDisk)->path($path);

        $directory = dirname($storagePath);
        if (! file_exists($directory)) {
            mkdir($directory, 0755, true);
        }

        $tableList = '';
        if ($specificTables) {
            $tableList = implode(' ', array_map('escapeshellarg', $specificTables));
        }

        $command = sprintf(
            'mysqldump --host=%s --port=%s --user=%s --password=%s --single-transaction --routines --triggers --no-tablespaces %s %s > %s 2>&1',
            escapeshellarg($config['host']),
            escapeshellarg($config['port'] ?? 3306),
            escapeshellarg($config['username']),
            escapeshellarg($config['password']),
            escapeshellarg($config['database']),
            $tableList,
            escapeshellarg($storagePath)
        );

        exec($command, $output, $returnCode);

        if ($returnCode === 0 && file_exists($storagePath) && filesize($storagePath) > 0) {
            return [
                'success' => true,
                'message' => 'Respaldo creado con mysqldump',
                'path' => $path,
                'size' => filesize($storagePath),
            ];
        }

        $error = implode("\n", $output);
        Log::error('mysqldump failed', ['command' => $command, 'output' => $error]);
        throw new \Exception("Error en mysqldump: {$error}");
    }

    /**
     * Crear respaldo usando pg_dump (solo PostgreSQL).
     *
     * @param  string       $path            Ruta relativa dentro de storage/app
     * @param  array|null   $specificTables  Tablas específicas a respaldar
     */
    protected function createBackupWithPgDump(string $path, ?array $specificTables = null): array
    {
        $config = config('database.connections.'.config('database.default'));
        $storagePath = Storage::disk($this->backupDisk)->path($path);

        $directory = dirname($storagePath);
        if (! file_exists($directory)) {
            mkdir($directory, 0755, true);
        }

        $host = $config['host'] ?? '127.0.0.1';
        $port = $config['port'] ?? 5432;
        $database = $config['database'];
        $username = $config['username'];
        $password = $config['password'] ?? '';
        $schema = $config['schema'] ?? 'public';

        // Tablas específicas
        $tableArgs = '';
        if (!empty($specificTables)) {
            foreach ($specificTables as $t) {
                $qualified = (strpos($t, '.') === false) ? ($schema . '.' . $t) : $t;
                $tableArgs .= ' -t ' . escapeshellarg($qualified);
            }
        }

        $env = '';
        if ($password !== '') {
            $env = 'PGPASSWORD='.escapeshellarg($password).' ';
        }

        // Formato plano (-F p) para coherencia con flujo actual
        $command = sprintf(
            '%spg_dump -h %s -p %s -U %s -n %s%s -F p -f %s %s 2>&1',
            $env,
            escapeshellarg($host),
            escapeshellarg((string)$port),
            escapeshellarg($username),
            escapeshellarg($schema),
            $tableArgs,
            escapeshellarg($storagePath),
            escapeshellarg($database)
        );

        exec($command, $output, $returnCode);

        if ($returnCode === 0 && file_exists($storagePath) && filesize($storagePath) > 0) {
            return [
                'success' => true,
                'message' => 'Respaldo creado con pg_dump',
                'path' => $path,
                'size' => filesize($storagePath),
            ];
        }

        $error = implode("\n", $output);
        Log::error('pg_dump failed', ['command' => $command, 'output' => $error]);
        throw new \Exception("Error en pg_dump: {$error}");
    }

    /**
     * Crear respaldo usando Laravel (portable entre drivers).
     *
     * @param  string  $path  Ruta relativa
     * @param  array|null  $specificTables  Tablas específicas a respaldar (null para todas)
     */
    protected function createBackupWithLaravel(string $path, ?array $specificTables = null): array
    {
        $fullPath = Storage::disk($this->backupDisk)->path($path);
        $directory = dirname($fullPath);
        if (! file_exists($directory)) {
            mkdir($directory, 0755, true);
        }

        $tables = $specificTables ? $this->getSpecificTables($specificTables) : $this->getAllTables();
        $sql = $this->generateSqlHeader();

        // Agregar comentario sobre tipo de backup
        if ($specificTables) {
            $sql = "-- Backup incremental - Tablas: " . implode(', ', $specificTables) . "\n" . $sql;
        }

        foreach ($tables as $table) {
            $sql .= $this->getTableStructure($table);
            $sql .= $this->getTableData($table);
        }

        $sql .= $this->getSqlFooter();

        if (Storage::disk($this->backupDisk)->put($path, $sql)) {
            return [
                'success' => true,
                'message' => 'Respaldo creado con Laravel',
                'path' => $path,
                'size' => Storage::disk($this->backupDisk)->size($path),
            ];
        }

        Log::error('No se pudo guardar el respaldo', [
            'path' => $fullPath,
            'disk' => $this->backupDisk,
            'sql_length' => strlen($sql),
        ]);

        throw new \Exception('No se pudo guardar el archivo de respaldo');
    }

    /**
     * Obtener tablas específicas según el driver.
     */
    protected function getSpecificTables(array $tableNames): array
    {
        $driver = config('database.default');
        $connection = config("database.connections.{$driver}");

        switch ($driver) {
            case 'mysql':
                $placeholders = str_repeat('?,', count($tableNames) - 1) . '?';
                return DB::select("SELECT table_name FROM information_schema.tables WHERE table_schema = ? AND table_name IN ({$placeholders})", array_merge([$connection['database']], $tableNames));
            case 'pgsql':
                $placeholders = str_repeat('?,', count($tableNames) - 1) . '?';
                return DB::select("SELECT tablename AS table_name FROM pg_tables WHERE schemaname = ? AND tablename IN ({$placeholders})", array_merge([$connection['schema'] ?? 'public'], $tableNames));
            case 'sqlite':
                $placeholders = str_repeat('?,', count($tableNames) - 1) . '?';
                return DB::select("SELECT name AS table_name FROM sqlite_master WHERE type = 'table' AND name NOT LIKE 'sqlite_%' AND name IN ({$placeholders})", $tableNames);
            default:
                throw new \Exception("Driver no soportado: {$driver}");
        }
    }

    /**
     * Obtener todas las tablas según el driver.
     */
    protected function getAllTables(): array
    {
        $driver = config('database.default');
        $connection = config("database.connections.{$driver}");

        switch ($driver) {
            case 'mysql':
                return DB::select('SELECT table_name FROM information_schema.tables WHERE table_schema = ?', [$connection['database']]);
            case 'pgsql':
                return DB::select('SELECT tablename AS table_name FROM pg_tables WHERE schemaname = ?', [$connection['schema'] ?? 'public']);
            case 'sqlite':
                return DB::select("SELECT name AS table_name FROM sqlite_master WHERE type = 'table' AND name NOT LIKE 'sqlite_%'");
            default:
                throw new \Exception("Driver no soportado: {$driver}");
        }
    }

    /**
     * Generar estructura SQL de una tabla.
     *
     * @param  object  $table
     */
    protected function getTableStructure($table): string
    {
        $tableName = $table->table_name ?? $table->TABLE_NAME;
        $driver = config('database.default');

        if ($driver === 'sqlite') {
            $row = DB::select("SELECT sql FROM sqlite_master WHERE type = 'table' AND name = ?", [$tableName])[0];

            return "\n-- Estructura de tabla `{$tableName}`\n".$row->sql.";\n\n";
        }

        if ($driver === 'pgsql') {
            $connection = config("database.connections.{$driver}");
            $schema = $connection['schema'] ?? 'public';

            // Obtener columnas de la tabla
            $columns = DB::select(
                "SELECT column_name, data_type, is_nullable, column_default, character_maximum_length, numeric_precision, numeric_scale
                 FROM information_schema.columns
                 WHERE table_schema = ? AND table_name = ?
                 ORDER BY ordinal_position",
                [$schema, $tableName]
            );

            $columnDefs = [];
            foreach ($columns as $col) {
                $colName = $col->column_name;
                $dataType = strtolower($col->data_type);
                $nullable = ($col->is_nullable === 'YES');
                $default = $col->column_default;

                // Ajustar tipos con longitud/precisión
                if ($dataType === 'character varying' && $col->character_maximum_length) {
                    $typeDef = 'varchar(' . (int)$col->character_maximum_length . ')';
                } elseif ($dataType === 'character' && $col->character_maximum_length) {
                    $typeDef = 'char(' . (int)$col->character_maximum_length . ')';
                } elseif ($dataType === 'numeric' && $col->numeric_precision) {
                    $scale = $col->numeric_scale ?? 0;
                    $typeDef = 'numeric(' . (int)$col->numeric_precision . ',' . (int)$scale . ')';
                } else {
                    // Otros tipos tal cual
                    $typeDef = $dataType;
                }

                $def = '"' . $colName . '" ' . $typeDef;
                if (!$nullable) {
                    $def .= ' NOT NULL';
                }
                if ($default !== null) {
                    $def .= ' DEFAULT ' . $default;
                }
                $columnDefs[] = $def;
            }

            // Clave primaria
            $pkCols = DB::select(
                "SELECT kcu.column_name
                 FROM information_schema.table_constraints tc
                 JOIN information_schema.key_column_usage kcu
                   ON tc.constraint_name = kcu.constraint_name
                  AND tc.table_schema = kcu.table_schema
                 WHERE tc.table_schema = ?
                   AND tc.table_name = ?
                   AND tc.constraint_type = 'PRIMARY KEY'
                 ORDER BY kcu.ordinal_position",
                [$schema, $tableName]
            );
            if (!empty($pkCols)) {
                $pkList = implode(', ', array_map(fn($c) => '"'.$c->column_name.'"', $pkCols));
                $columnDefs[] = 'PRIMARY KEY (' . $pkList . ')';
            }

            $ddl = "\n-- Estructura de tabla \"{$tableName}\"\n";
            $ddl .= 'CREATE TABLE IF NOT EXISTS "' . $tableName . '" (' . "\n  " . implode(",\n  ", $columnDefs) . "\n" . ")" . ";\n\n";
            return $ddl;
        }

        // MySQL
        $row = DB::select("SHOW CREATE TABLE `{$tableName}`")[0];

        return "\n-- Estructura de tabla `{$tableName}`\n".$row->{'Create Table'}.";\n\n";
    }

    /**
     * Generar datos SQL de una tabla.
     *
     * @param  object  $table
     */
    protected function getTableData($table): string
    {
        $tableName = $table->table_name ?? $table->TABLE_NAME;
        $driver = config('database.default');
        $rows = DB::table($tableName)->get()->toArray();

        if (empty($rows)) {
            return '';
        }

        $colNames = array_keys((array) $rows[0]);
        if ($driver === 'pgsql') {
            $columns = '"'.implode('", "', $colNames).'"';
            $sql = "-- Datos de tabla \"{$tableName}\"\nINSERT INTO \"{$tableName}\" ({$columns}) VALUES\n";
        } else {
            $columns = '`'.implode('`, `', $colNames).'`';
            $sql = "-- Datos de tabla `{$tableName}`\nINSERT INTO `{$tableName}` ({$columns}) VALUES\n";
        }

        $values = [];
        foreach ($rows as $row) {
            $vals = array_map(function ($value) use ($driver) {
                if ($value === null) {
                    return 'NULL';
                }
                if (is_bool($value)) {
                    return $driver === 'pgsql' ? ($value ? 'TRUE' : 'FALSE') : ($value ? '1' : '0');
                }
                if (is_numeric($value)) {
                    return (string)$value;
                }
                $str = (string)$value;
                if ($driver === 'pgsql') {
                    $str = str_replace("'", "''", $str);
                } else {
                    $str = addslashes($str);
                }
                return "'".$str."'";
            }, (array) $row);
            $values[] = '('.implode(', ', $vals).')';
        }

        return $sql.implode(",\n", $values).";\n\n";
    }

    /**
     * Encabezado SQL según driver.
     */
    protected function generateSqlHeader(): string
    {
        $driver = config('database.default');
        $dbName = config("database.connections.{$driver}.database");

        switch ($driver) {
            case 'mysql':
                return "-- MySQL Backup\n-- DB: {$dbName}\n-- Fecha: ".now()."\n\nSET FOREIGN_KEY_CHECKS=0;\nSTART TRANSACTION;\n";
            case 'pgsql':
                return "-- PostgreSQL Backup\n-- DB: {$dbName}\n-- Fecha: ".now()."\n\nBEGIN;\n";
            case 'sqlite':
                return "-- SQLite Backup\n-- DB: ".basename($dbName)."\n-- Fecha: ".now()."\n\nPRAGMA foreign_keys=OFF;\nBEGIN TRANSACTION;\n";
            default:
                return "-- Backup\n-- Fecha: ".now()."\n";
        }
    }

    /**
     * Pie de archivo SQL.
     */
    protected function getSqlFooter(): string
    {
        $driver = config('database.default');
        switch ($driver) {
            case 'mysql':
                return "\nSET FOREIGN_KEY_CHECKS=1;\nCOMMIT;\n";
            case 'pgsql':
                return "\nCOMMIT;\n";
            case 'sqlite':
                return "\nCOMMIT;\n";
            default:
                return "\nCOMMIT;\n";
        }
    }

    /**
     * Comprimir un archivo SQL en ZIP con compresión inteligente.
     *
     * @param  string  $filePath  Ruta relativa
     * @param  array  $options  Opciones de compresión
     */
    public function compressBackup(string $filePath, array $options = []): array
    {
        $storagePath = Storage::disk($this->backupDisk)->path($filePath);

        if (! file_exists($storagePath)) {
            return ['success' => false, 'message' => "Archivo no encontrado: {$storagePath}"];
        }

        $fileSize = filesize($storagePath);
        $compressionLevel = $this->determineOptimalCompression($fileSize, $options);

        // Si el archivo es muy pequeño, no comprimir
        if ($compressionLevel === 0) {
            return [
                'success' => true,
                'message' => 'Archivo pequeño, no requiere compresión',
                'path' => $filePath,
                'size' => $fileSize,
                'compression_skipped' => true
            ];
        }

        $zipPath = str_replace('.sql', '.zip', $storagePath);

        $zip = new ZipArchive;

        // Abrir con el nivel de compresión óptimo
        $result = $zip->open($zipPath, ZipArchive::CREATE);

        if ($result !== true) {
            $errors = [
                ZipArchive::ER_EXISTS => 'Ya existe',
                ZipArchive::ER_INCONS => 'Inconsistencia',
                ZipArchive::ER_INVAL => 'Inválido',
                ZipArchive::ER_MEMORY => 'Sin memoria',
                ZipArchive::ER_NOENT => 'No encontrado',
                ZipArchive::ER_OPEN => 'No se pudo abrir',
            ];

            return ['success' => false, 'message' => $errors[$result] ?? "Error ZIP: {$result}"];
        }

        // Configurar nivel de compresión
        if ($compressionLevel > 0) {
            $zip->setCompressionIndex(0, $compressionLevel);
        }

        if (! $zip->addFile($storagePath, basename($storagePath))) {
            $zip->close();
            @unlink($zipPath);

            return ['success' => false, 'message' => 'No se pudo agregar al ZIP'];
        }

        $zip->close();

        if (! file_exists($zipPath)) {
            return ['success' => false, 'message' => 'ZIP no creado'];
        }

        $compressedSize = filesize($zipPath);
        $compressionRatio = round((1 - ($compressedSize / $fileSize)) * 100, 2);

        // Eliminar archivo original después de comprimir
        unlink($storagePath);
        $diskRoot = rtrim(Storage::disk($this->backupDisk)->path(''), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
        $relativePath = str_replace($diskRoot, '', $zipPath);

        return [
            'success' => true,
            'message' => "Comprimido OK (Ratio: {$compressionRatio}%)",
            'path' => $relativePath,
            'size' => $compressedSize,
            'original_size' => $fileSize,
            'compression_ratio' => $compressionRatio,
            'compression_level' => $compressionLevel
        ];
    }

    /**
     * Listar todos los respaldos disponibles.
     */
    public function listBackups(): array
    {
        $files = Storage::disk($this->backupDisk)->files($this->backupPath);
        $backups = [];

        foreach ($files as $file) {
            if (! preg_match('/\.(sql|zip)$/', $file)) {
                continue;
            }
            if (! Storage::disk($this->backupDisk)->exists($file)) {
                continue;
            }

            try {
                $size = Storage::disk($this->backupDisk)->size($file);
                $mtime = Storage::disk($this->backupDisk)->lastModified($file);

                $backups[] = [
                    'name' => basename($file),
                    'path' => $file,
                    'size' => $size,
                    'size_human' => $this->formatBytes($size),
                    'created_at' => Carbon::createFromTimestamp($mtime)->format('Y-m-d H:i:s'),
                    'type' => pathinfo($file, PATHINFO_EXTENSION),
                ];
            } catch (\Exception $e) {
                Log::error("Error leyendo respaldo: {$file}", ['exception' => $e]);
            }
        }

        usort($backups, fn ($a, $b) => strtotime($b['created_at']) - strtotime($a['created_at']));

        return $backups;
    }

    /**
     * Verificar si un respaldo existe.
     *
     * @param  string  $filename  Nombre del archivo
     */
    public function backupExists(string $filename): bool
    {
        $path = $this->backupPath.$filename;
        return Storage::disk($this->backupDisk)->exists($path);
    }

    /**
     * Obtener la ruta física del archivo de respaldo.
     *
     * @param  string  $filename  Nombre del archivo
     * @return string Ruta completa
     */
    public function getBackupPath(string $filename): string
    {
        return Storage::disk($this->backupDisk)->path($this->backupPath.$filename);
    }

    /**
     * Eliminar un archivo de respaldo.
     *
     * @param  string  $filename  Nombre del archivo
     */
    public function deleteBackup(string $filename): array
    {
        $path = $this->backupPath.$filename;

        if (! Storage::disk($this->backupDisk)->exists($path)) {
            return ['success' => false, 'message' => 'El archivo no existe.'];
        }

        $size = Storage::disk($this->backupDisk)->size($path);
        if (Storage::disk($this->backupDisk)->delete($path)) {
            return [
                'success' => true,
                'message' => 'Respaldo eliminado.',
                'freed_space' => $size,
            ];
        }

        return ['success' => false, 'message' => 'No se pudo eliminar el archivo.'];
    }

    /**
     * Restaurar la base de datos desde un respaldo con soporte para desencriptación.
     *
     * @param  string  $filename  Nombre del archivo
     * @param  array  $options  Opciones de restauración
     */
    public function restoreBackup(string $filename, array $options = []): array
    {
        $options = array_merge([
            'verify_integrity' => true,
            'create_prerestore_backup' => true,
            'dry_run' => false,
            'tables_to_restore' => null, // Para restauración granular
            'skip_sensitive_tables' => false
        ], $options);

        DB::beginTransaction();
        try {
            $path = $this->backupPath.$filename;
            if (! Storage::disk($this->backupDisk)->exists($path)) {
                throw new \Exception('Archivo no existe');
            }

            // Verificación de integridad antes de restaurar
            if ($options['verify_integrity']) {
                $integrityCheck = $this->verifyBackupIntegrity($path);
                if (!$integrityCheck['success']) {
                    throw new \Exception('Verificación de integridad fallida: ' . ($integrityCheck['message'] ?? 'Error desconocido'));
                }

                if (!empty($integrityCheck['warnings'])) {
                    Log::warning('Advertencias en verificación de integridad', [
                        'filename' => $filename,
                        'warnings' => $integrityCheck['warnings']
                    ]);
                }
            }

            $storagePath = Storage::disk($this->backupDisk)->path($path);
            $sqlContent = '';

            // Crear respaldo previo si está habilitado
            if ($options['create_prerestore_backup']) {
                $preRestoreResult = $this->createBackup([
                    'name' => 'pre_restore_' . date('Y-m-d_H-i-s'),
                    'compress' => true
                ]);

                if (!$preRestoreResult['success']) {
                    Log::warning('No se pudo crear respaldo previo: ' . $preRestoreResult['message']);
                }
            }

            // Procesar archivo según tipo
            if (pathinfo($filename, PATHINFO_EXTENSION) === 'zip') {
                $sqlContent = $this->extractFromZip($storagePath);
            } else {
                $rawContent = Storage::disk($this->backupDisk)->get($path);

                // Desencriptar si es necesario
                if ($this->isEncrypted($rawContent)) {
                    $rawContent = $this->decryptContent($rawContent);
                }

                $sqlContent = $rawContent;
            }

            // Restauración granular si se especifican tablas
            if ($options['tables_to_restore']) {
                $sqlContent = $this->filterTablesInSql($sqlContent, $options['tables_to_restore']);
            }

            // Saltar tablas sensibles si está habilitado
            if ($options['skip_sensitive_tables']) {
                $sqlContent = $this->removeSensitiveTables($sqlContent);
            }

            // Dry run - solo verificar sintaxis sin ejecutar
            if ($options['dry_run']) {
                DB::rollBack();
                return [
                    'success' => true,
                    'message' => 'Verificación de sintaxis completada (dry run)',
                    'dry_run' => true,
                    'sql_preview' => substr($sqlContent, 0, 500) . '...'
                ];
            }

            DB::unprepared($sqlContent);
            DB::commit();

            Log::info('Restauración completada exitosamente', [
                'filename' => $filename,
                'options' => $options,
                'tables_restored' => $options['tables_to_restore']
            ]);

            // Enviar notificación de restauración exitosa
            $this->sendNotification('restore_success', [
                'filename' => $filename,
                'tables_restored' => $options['tables_to_restore'] ?: 'all',
                'dry_run' => $options['dry_run'] ?? false
            ]);

            return [
                'success' => true,
                'message' => 'Base de datos restaurada exitosamente.',
                'tables_restored' => $options['tables_to_restore'] ?: 'all'
            ];
        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Error en restauración: ' . $e->getMessage(), [
                'filename' => $filename,
                'options' => $options
            ]);

            // Enviar notificación de error en restauración
            $this->sendNotification('restore_failure', [
                'filename' => $filename,
                'error' => $e->getMessage(),
                'options' => $options
            ]);

            return ['success' => false, 'message' => 'Error: '.$e->getMessage()];
        }
    }

    /**
     * Verificar si el contenido está encriptado
     */
    protected function isEncrypted(string $content): bool
    {
        // Intentar desencriptar para verificar si está encriptado
        try {
            Crypt::decrypt($content);
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Desencriptar contenido
     */
    protected function decryptContent(string $encryptedContent): string
    {
        try {
            return Crypt::decrypt($encryptedContent);
        } catch (\Exception $e) {
            throw new \Exception('No se pudo desencriptar el contenido: ' . $e->getMessage());
        }
    }

    /**
     * Extraer contenido SQL desde archivo ZIP
     */
    protected function extractFromZip(string $zipPath): string
    {
        $zip = new ZipArchive;
        if ($zip->open($zipPath) !== true) {
            throw new \Exception('No se pudo abrir el archivo ZIP');
        }

        $tempDir = storage_path('app/temp_restore/');
        if (!is_dir($tempDir)) {
            mkdir($tempDir, 0755, true);
        }

        $zip->extractTo($tempDir);
        $zip->close();

        $sqlFiles = glob($tempDir . '*.sql');
        if (empty($sqlFiles)) {
            // Limpiar archivos temporales
            array_map('unlink', glob($tempDir . '*'));
            rmdir($tempDir);
            throw new \Exception('No se encontraron archivos SQL en el ZIP');
        }

        $sqlContent = file_get_contents($sqlFiles[0]);

        // Limpiar archivos temporales
        array_map('unlink', glob($tempDir . '*'));
        rmdir($tempDir);

        return $sqlContent;
    }

    /**
     * Crear restauración granular con opciones avanzadas
     *
     * @param  string  $filename  Nombre del archivo de respaldo
     * @param  array  $options  Opciones avanzadas de restauración granular
     */
    public function granularRestore(string $filename, array $options = []): array
    {
        $options = array_merge([
            'tables_to_restore' => [],
            'tables_to_exclude' => [],
            'include_structure' => true,
            'include_data' => true,
            'dry_run' => false,
            'create_restore_log' => true,
            'backup_before_restore' => true,
            'verify_integrity' => true,
            'remap_table_names' => [], // Para restaurar con nombres diferentes
            'where_conditions' => [], // Condiciones WHERE para filtrar datos
            'chunk_size' => 1000 // Procesar en chunks para tablas grandes
        ], $options);

        if (empty($options['tables_to_restore']) && empty($options['tables_to_exclude'])) {
            return [
                'success' => false,
                'message' => 'Debe especificar tablas a restaurar o excluir'
            ];
        }

        DB::beginTransaction();
        try {
            // Verificación previa
            if ($options['verify_integrity']) {
                $integrityCheck = $this->verifyAdvancedIntegrity($filename);
                if (!$integrityCheck['success']) {
                    throw new \Exception('Verificación de integridad fallida: ' . $integrityCheck['message']);
                }
            }

            // Crear respaldo previo si está habilitado
            if ($options['backup_before_restore']) {
                $preRestoreResult = $this->createBackup([
                    'name' => 'pre_granular_restore_' . date('Y-m-d_H-i-s'),
                    'compress' => true
                ]);

                if (!$preRestoreResult['success']) {
                    Log::warning('No se pudo crear respaldo previo: ' . $preRestoreResult['message']);
                }
            }

            // Procesar archivo de respaldo
            $sqlContent = $this->extractSqlContent($filename);

            // Aplicar filtros granulares
            $filteredSql = $this->applyGranularFilters($sqlContent, $options);

            // Dry run - solo verificar sintaxis
            if ($options['dry_run']) {
                DB::rollBack();
                return [
                    'success' => true,
                    'message' => 'Verificación de sintaxis completada (dry run)',
                    'dry_run' => true,
                    'sql_preview' => substr($filteredSql, 0, 500) . '...',
                    'estimated_tables' => $this->estimateTablesInSql($filteredSql),
                    'estimated_rows' => $this->estimateRowsInSql($filteredSql)
                ];
            }

            // Ejecutar restauración granular
            $result = $this->executeGranularRestore($filteredSql, $options);

            DB::commit();

            // Crear log de restauración si está habilitado
            if ($options['create_restore_log']) {
                $this->createRestoreLog($filename, $options, $result);
            }

            // Enviar notificación
            $this->sendNotification('restore_success', [
                'filename' => $filename,
                'granular_restore' => true,
                'tables_restored' => implode(', ', $options['tables_to_restore'] ?: $options['tables_to_exclude']),
                'dry_run' => false
            ]);

            return [
                'success' => true,
                'message' => 'Restauración granular completada exitosamente',
                'tables_processed' => $result['tables_processed'],
                'rows_affected' => $result['rows_affected'],
                'structure_restored' => $result['structure_restored'],
                'data_restored' => $result['data_restored']
            ];

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Error en restauración granular: ' . $e->getMessage(), [
                'filename' => $filename,
                'options' => $options
            ]);

            $this->sendNotification('restore_failure', [
                'filename' => $filename,
                'error' => $e->getMessage(),
                'granular_restore' => true
            ]);

            return [
                'success' => false,
                'message' => 'Error en restauración granular: ' . $e->getMessage()
            ];
        }
    }

    /**
     * Extraer contenido SQL de archivo (soporta encriptación)
     */
    protected function extractSqlContent(string $filename): string
    {
        $path = $this->backupPath . $filename;

        if (!Storage::disk($this->backupDisk)->exists($path)) {
            throw new \Exception('Archivo no existe');
        }

        $storagePath = storage_path('app/' . $path);
        $sqlContent = '';

        if (pathinfo($filename, PATHINFO_EXTENSION) === 'zip') {
            $sqlContent = $this->extractFromZip($storagePath);
        } else {
            $rawContent = Storage::disk($this->backupDisk)->get($path);

            // Desencriptar si es necesario
            if ($this->isEncrypted($rawContent)) {
                $rawContent = $this->decryptContent($rawContent);
            }

            $sqlContent = $rawContent;
        }

        return $sqlContent;
    }

    /**
     * Aplicar filtros granulares al contenido SQL
     */
    protected function applyGranularFilters(string $sqlContent, array $options): string
    {
        $lines = explode("\n", $sqlContent);
        $filteredLines = [];
        $currentTable = null;
        $inCreateStatement = false;
        $inInsertStatement = false;
        $inTableStructure = false;

        foreach ($lines as $line) {
            $originalLine = $line;

            // Detectar tipo de statement
            if (preg_match('/CREATE TABLE [`"]?(\w+)[`"]?/i', $line, $matches)) {
                $currentTable = strtolower($matches[1]);
                $inCreateStatement = true;
                $inTableStructure = true;
            } elseif (preg_match('/INSERT INTO [`"]?(\w+)[`"]?/i', $line, $matches)) {
                $currentTable = strtolower($matches[1]);
                $inInsertStatement = true;
                $inTableStructure = false;
            } elseif (preg_match('/DROP TABLE [`"]?(\w+)[`"]?/i', $line, $matches)) {
                $currentTable = strtolower($matches[1]);
            }

            // Aplicar filtros de tabla
            $includeLine = $this->shouldIncludeTable($currentTable, $options);

            // Aplicar remapeo de nombres si está configurado
            if ($includeLine && $currentTable && isset($options['remap_table_names'][$currentTable])) {
                $line = $this->remapTableName($line, $currentTable, $options['remap_table_names'][$currentTable]);
            }

            // Aplicar condiciones WHERE si están configuradas
            if ($includeLine && $inInsertStatement && $currentTable && isset($options['where_conditions'][$currentTable])) {
                $line = $this->applyWhereConditions($line, $options['where_conditions'][$currentTable]);
            }

            // Incluir línea si pasa los filtros
            if ($includeLine) {
                $filteredLines[] = $line;
            }

            // Detectar fin de statements
            if ($inCreateStatement && strpos($line, ';') !== false && !preg_match('/CREATE TABLE/i', $line)) {
                $inCreateStatement = false;
                $inTableStructure = false;
                $currentTable = null;
            }

            if ($inInsertStatement && strpos($line, ';') !== false && substr_count($line, "'") % 2 == 0) {
                $inInsertStatement = false;
                $currentTable = null;
            }
        }

        return implode("\n", $filteredLines);
    }

    /**
     * Determinar si una tabla debe incluirse según opciones
     */
    protected function shouldIncludeTable(?string $tableName, array $options): bool
    {
        if (!$tableName) {
            return true; // Incluir líneas que no pertenecen a tablas específicas
        }

        // Si se especifican tablas a restaurar, solo incluir esas
        if (!empty($options['tables_to_restore'])) {
            return in_array($tableName, $options['tables_to_restore']);
        }

        // Si se especifican tablas a excluir, incluir todas menos esas
        if (!empty($options['tables_to_exclude'])) {
            return !in_array($tableName, $options['tables_to_exclude']);
        }

        return true;
    }

    /**
     * Remapear nombre de tabla en línea SQL
     */
    protected function remapTableName(string $line, string $originalName, string $newName): string
    {
        return str_ireplace($originalName, $newName, $line);
    }

    /**
     * Aplicar condiciones WHERE a statements INSERT
     */
    protected function applyWhereConditions(string $line, array $conditions): string
    {
        // Esta es una implementación básica - en producción requeriría parsing SQL más sofisticado
        foreach ($conditions as $column => $value) {
            if (stripos($line, 'VALUES') !== false) {
                // Agregar condición WHERE después del INSERT
                $line = rtrim($line, ';') . " WHERE {$column} = '{$value}';";
                break;
            }
        }

        return $line;
    }

    /**
     * Ejecutar restauración granular procesando el SQL filtrado
     */
    protected function executeGranularRestore(string $sqlContent, array $options): array
    {
        $result = [
            'tables_processed' => 0,
            'rows_affected' => 0,
            'structure_restored' => false,
            'data_restored' => false
        ];

        // Dividir SQL en statements individuales
        $statements = $this->splitSqlStatements($sqlContent);

        foreach ($statements as $statement) {
            $statement = trim($statement);

            if (empty($statement) || strpos($statement, '--') === 0) {
                continue;
            }

            // Detectar tipo de statement
            if (stripos($statement, 'CREATE TABLE') === 0 && $options['include_structure']) {
                DB::unprepared($statement);
                $result['structure_restored'] = true;
                $result['tables_processed']++;
            } elseif (stripos($statement, 'INSERT INTO') === 0 && $options['include_data']) {
                // Procesar en chunks para tablas grandes
                if ($options['chunk_size'] > 0) {
                    $this->executeChunkedInsert($statement, $options['chunk_size']);
                } else {
                    DB::unprepared($statement);
                }

                $result['data_restored'] = true;
                $result['rows_affected']++;
            }
        }

        return $result;
    }

    /**
     * Dividir contenido SQL en statements individuales
     */
    protected function splitSqlStatements(string $sqlContent): array
    {
        $statements = [];
        $lines = explode("\n", $sqlContent);
        $currentStatement = '';
        $inString = false;
        $quoteChar = '';

        foreach ($lines as $line) {
            $line = trim($line);

            // Detectar inicio/fin de strings
            for ($i = 0; $i < strlen($line); $i++) {
                $char = $line[$i];

                if (($char === '"' || $char === "'") && ($i === 0 || $line[$i-1] !== '\\')) {
                    if (!$inString) {
                        $inString = true;
                        $quoteChar = $char;
                    } elseif ($char === $quoteChar) {
                        $inString = false;
                        $quoteChar = '';
                    }
                }
            }

            $currentStatement .= $line . "\n";

            // Si no estamos dentro de un string y encontramos punto y coma, es fin de statement
            if (!$inString && strpos($line, ';') !== false) {
                $statements[] = $currentStatement;
                $currentStatement = '';
            }
        }

        // Agregar statement restante si existe
        if (!empty(trim($currentStatement))) {
            $statements[] = $currentStatement;
        }

        return $statements;
    }

    /**
     * Ejecutar INSERT en chunks para manejar tablas grandes
     */
    protected function executeChunkedInsert(string $insertStatement, int $chunkSize): void
    {
        // Esta es una implementación básica - en producción requeriría parsing SQL avanzado
        try {
            DB::unprepared($insertStatement);
        } catch (\Exception $e) {
            Log::warning('Error en INSERT chunked, ejecutando normalmente: ' . $e->getMessage());
            DB::unprepared($insertStatement);
        }
    }

    /**
     * Crear log detallado de restauración granular
     */
    protected function createRestoreLog(string $filename, array $options, array $result): void
    {
        try {
            BackupLog::create([
                'filename' => 'granular_restore_' . basename($filename) . '_' . now()->format('Y-m-d_H-i-s'),
                'path' => $this->backupPath . $filename,
                'type' => 'restore',
                'method' => 'granular',
                'status' => 'success',
                'message' => 'Restauración granular completada',
                'metadata' => [
                    'original_backup' => $filename,
                    'tables_processed' => $result['tables_processed'],
                    'rows_affected' => $result['rows_affected'],
                    'options' => $options
                ]
            ]);
        } catch (\Exception $e) {
            Log::warning('No se pudo crear log de restauración granular: ' . $e->getMessage());
        }
    }

    /**
     * Filtrar tablas específicas en contenido SQL
     */
    protected function filterTablesInSql(string $sqlContent, array $tablesToRestore): string
    {
        $lines = explode("\n", $sqlContent);
        $filteredLines = [];
        $currentTable = null;
        $inCreateStatement = false;
        $inInsertStatement = false;

        foreach ($lines as $line) {
            // Detectar inicio de CREATE TABLE
            if (preg_match('/CREATE TABLE [`"]?(\w+)[`"]?/i', $line, $matches)) {
                $currentTable = strtolower($matches[1]);
                $inCreateStatement = true;
            }

            // Detectar inicio de INSERT
            if (preg_match('/INSERT INTO [`"]?(\w+)[`"]?/i', $line, $matches)) {
                $currentTable = strtolower($matches[1]);
                $inInsertStatement = true;
            }

            // Incluir línea si la tabla está en la lista de tablas a restaurar
            if (($inCreateStatement || $inInsertStatement) && $currentTable && in_array($currentTable, $tablesToRestore)) {
                $filteredLines[] = $line;
            } elseif (!$inCreateStatement && !$inInsertStatement) {
                // Incluir líneas que no son parte de CREATE ni INSERT
                $filteredLines[] = $line;
            }


